/*
 *             Copyright Andrej Mitrovic 2013.
 *  Distributed under the Boost Software License, Version 1.0.
 *     (See accompanying file LICENSE_1_0.txt or copy at
 *           http://www.boost.org/LICENSE_1_0.txt)
 */
module minilib.core.functional;

import std.string;
import std.traits;
import std.typecons;
import std.typetuple;

import minilib.core.string;
import minilib.core.typecons;

/**
    Associate default values to a function in reverse.
*/
template CurryDefVal(alias Call, DefVals...)
{
    // can't add constraints due to compiler bugs

    static if (is(typeof( CurryDefValImpl1!(Call, DefVals) )))
    {
        alias CurryDefValImpl1!(Call, DefVals) CurryDefVal;
    }
    else  // can't add check due to compiler bugs
    {
        alias CurryDefValImpl2!(Call, DefVals) CurryDefVal;
    }
}

///
unittest
{
    static void foo(int x, float y, string z)
    {
        // writefln("x: %s, y: %s, z: %s", x, y, z);
    }

    alias fooDef3 = CurryDefVal!(foo, "a", 1.0, 1);
    alias fooDef2 = CurryDefVal!(foo, "a", 1.0);
    alias fooDef1 = CurryDefVal!(foo, "a");
    alias fooDef0 = CurryDefVal!(foo);
    alias fooDef3_clone = CurryDefVal!(fooDef1, 2.0, 3);

    fooDef0(1, 1.0, "a");
    fooDef1(1, 1.0);
    fooDef2(1);
    fooDef3();
    fooDef3_clone();

    // demonstrates alias of scoped function
    static void testMe(ref int y)
    {
        //~ writeln(y);
        if (y == 10)
            return;

        // @bug: Regression: Frame access error
        // http://d.puremagic.com/issues/show_bug.cgi?id=10877
        /+ alias CurryDefVal!(testMe, y) recurse;

        y = 10;
        recurse(); +/
    }

    int x;
    testMe(x);
}

/* helper */
template CurryDefValImpl1(alias Call, DefVals...)
    if (isCallable!Call && DefVals.length <= ParameterTypeTuple!Call.length)
{
    auto CurryDefValImpl1(T...)(T args)
    {
        return Call(args, Reverse!DefVals);
    }
}

/* helper */
struct CurryDefValImpl2(alias Call, DefVals...)
{
    static auto opCall(T...)(T args)
    {
        return Call(args, Reverse!DefVals);
    }
}

/+
Note: Disabled due to Issue 9851

/**
    Mixin that generates a constructor that acts as a field-initializer.
    Useful when adding a custom ctor disables the autogenerated field ctor.
*/
mixin template FieldInitCtor()
{
    this(RepresentationTypeTuple!(typeof(this)) params)
    {
        enum FieldLen = RepresentationTypeTuple!(typeof(this)).length;

        foreach (idx, member; __traits(allMembers, typeof(this))[0 .. FieldLen])
        {
            __traits(getMember, this, member) = params[idx];
        }
    }
}

///
unittest
{
    static struct S
    {
        int a;
        int b;
        int c;
        int d;

        mixin FieldInitCtor!();
        this(string x) { }
    }

    auto s = S(1, 2, 3, 4);
    assert(s == S(1, 2, 3, 4));
} +/

/**
    Return a tuple of aliases as a Tuple struct, which will
    also expose the names of the aliases as fields.
*/
deprecated alias tuplify = minilib.core.typecons.tuple;
